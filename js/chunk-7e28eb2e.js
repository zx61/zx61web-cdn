import{bq as z}from"./chunk-a0327024.js";const M={},$=Object.freeze(Object.defineProperty({__proto__:null,default:M},Symbol.toStringTag,{value:"Module"})),Re=z($);function B(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function k(e){if(typeof e!="boolean")throw new Error(`Expected boolean, not ${e}`)}function S(e,...D){if(!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(D.length>0&&!D.includes(e.length))throw new TypeError(`Expected Uint8Array of length ${D}, not of length=${e.length}`)}function L(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");B(e.outputLen),B(e.blockLen)}function N(e,D=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(D&&e.finished)throw new Error("Hash#digest() has already been called")}function R(e,D){S(e);const u=D.outputLen;if(e.length<u)throw new Error(`digestInto() expects output buffer of length at least ${u}`)}const qe={number:B,bool:k,bytes:S,hash:L,exists:N,output:R},_=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ve=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Ie=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),Je=(e,D)=>e<<32-D|e>>>D,q=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!q)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(e,D)=>D.toString(16).padStart(2,"0"));function V(e){if(typeof e!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);return new TextEncoder().encode(e)}function j(e){if(typeof e=="string"&&(e=V(e)),!(e instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);return e}function Ke(...e){if(!e.every(t=>t instanceof Uint8Array))throw new Error("Uint8Array list expected");if(e.length===1)return e[0];const D=e.reduce((t,r)=>t+r.length,0),u=new Uint8Array(D);for(let t=0,r=0;t<e.length;t++){const o=e[t];u.set(o,r),r+=o.length}return u}class Ge{clone(){return this._cloneInto()}}function He(e){const D=t=>e().update(j(t)).digest(),u=e();return D.outputLen=u.outputLen,D.blockLen=u.blockLen,D.create=()=>e(),D}function Qe(e){const D=(t,r)=>e(r).update(j(t)).digest(),u=e({});return D.outputLen=u.outputLen,D.blockLen=u.blockLen,D.create=t=>e(t),D}function We(e=32){if(_&&typeof _.getRandomValues=="function")return _.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function I(e,D){if(e.length>=255)throw new TypeError("Alphabet too long");for(var u=new Uint8Array(256),t=0;t<u.length;t++)u[t]=255;for(var r=0;r<e.length;r++){var o=e.charAt(r),c=o.charCodeAt(0);if(u[c]!==255)throw new TypeError(o+" is ambiguous");u[c]=r}var a=e.length,l=e.charAt(0),v=Math.log(a)/Math.log(256),b=Math.log(256)/Math.log(a);function m(n){if(n instanceof Uint8Array||(ArrayBuffer.isView(n)?n=new Uint8Array(n.buffer,n.byteOffset,n.byteLength):Array.isArray(n)&&(n=Uint8Array.from(n))),!(n instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(n.length===0)return"";for(var s=0,g=0,p=0,E=n.length;p!==E&&n[p]===0;)p++,s++;for(var h=(E-p)*b+1>>>0,f=new Uint8Array(h);p!==E;){for(var C=n[p],w=0,d=h-1;(C!==0||w<g)&&d!==-1;d--,w++)C+=256*f[d]>>>0,f[d]=C%a>>>0,C=C/a>>>0;if(C!==0)throw new Error("Non-zero carry");g=w,p++}for(var y=h-g;y!==h&&f[y]===0;)y++;for(var F=l.repeat(s);y<h;++y)F+=e.charAt(f[y]);return F}function U(n){if(typeof n!="string")throw new TypeError("Expected String");if(n.length===0)return new Uint8Array;var s=0;if(n[s]!==" "){for(var g=0,p=0;n[s]===l;)g++,s++;for(var E=(n.length-s)*v+1>>>0,h=new Uint8Array(E);n[s];){var f=u[n.charCodeAt(s)];if(f===255)return;for(var C=0,w=E-1;(f!==0||C<p)&&w!==-1;w--,C++)f+=a*h[w]>>>0,h[w]=f%256>>>0,f=f/256>>>0;if(f!==0)throw new Error("Non-zero carry");p=C,s++}if(n[s]!==" "){for(var d=E-p;d!==E&&h[d]===0;)d++;for(var y=new Uint8Array(g+(E-d)),F=g;d!==E;)y[F++]=h[d++];return y}}}function P(n){var s=U(n);if(s)return s;throw new Error(`Non-${D} character`)}return{encode:m,decodeUnsafe:U,decode:P}}var J=I,K=J;const G=e=>{if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")},H=e=>new TextEncoder().encode(e),Q=e=>new TextDecoder().decode(e);class W{constructor(D,u,t){this.name=D,this.prefix=u,this.baseEncode=t}encode(D){if(D instanceof Uint8Array)return`${this.prefix}${this.baseEncode(D)}`;throw Error("Unknown type, must be binary type")}}class X{constructor(D,u,t){if(this.name=D,this.prefix=u,u.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=u.codePointAt(0),this.baseDecode=t}decode(D){if(typeof D=="string"){if(D.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(D)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(D.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(D){return O(this,D)}}class Z{constructor(D){this.decoders=D}or(D){return O(this,D)}decode(D){const u=D[0],t=this.decoders[u];if(t)return t.decode(D);throw RangeError(`Unable to decode multibase string ${JSON.stringify(D)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const O=(e,D)=>new Z({...e.decoders||{[e.prefix]:e},...D.decoders||{[D.prefix]:D}});class Y{constructor(D,u,t,r){this.name=D,this.prefix=u,this.baseEncode=t,this.baseDecode=r,this.encoder=new W(D,u,t),this.decoder=new X(D,u,r)}encode(D){return this.encoder.encode(D)}decode(D){return this.decoder.decode(D)}}const x=({name:e,prefix:D,encode:u,decode:t})=>new Y(e,D,u,t),A=({prefix:e,name:D,alphabet:u})=>{const{encode:t,decode:r}=K(u,D);return x({prefix:e,name:D,encode:t,decode:o=>G(r(o))})},ee=(e,D,u,t)=>{const r={};for(let b=0;b<D.length;++b)r[D[b]]=b;let o=e.length;for(;e[o-1]==="=";)--o;const c=new Uint8Array(o*u/8|0);let a=0,l=0,v=0;for(let b=0;b<o;++b){const m=r[e[b]];if(m===void 0)throw new SyntaxError(`Non-${t} character`);l=l<<u|m,a+=u,a>=8&&(a-=8,c[v++]=255&l>>a)}if(a>=u||255&l<<8-a)throw new SyntaxError("Unexpected end of data");return c},De=(e,D,u)=>{const t=D[D.length-1]==="=",r=(1<<u)-1;let o="",c=0,a=0;for(let l=0;l<e.length;++l)for(a=a<<8|e[l],c+=8;c>u;)c-=u,o+=D[r&a>>c];if(c&&(o+=D[r&a<<u-c]),t)for(;o.length*u&7;)o+="=";return o},i=({name:e,prefix:D,bitsPerChar:u,alphabet:t})=>x({prefix:D,name:e,encode(r){return De(r,t,u)},decode(r){return ee(r,t,u,e)}}),ue=x({prefix:"\0",name:"identity",encode:e=>Q(e),decode:e=>H(e)}),te=Object.freeze(Object.defineProperty({__proto__:null,identity:ue},Symbol.toStringTag,{value:"Module"})),re=i({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),ne=Object.freeze(Object.defineProperty({__proto__:null,base2:re},Symbol.toStringTag,{value:"Module"})),oe=i({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),ae=Object.freeze(Object.defineProperty({__proto__:null,base8:oe},Symbol.toStringTag,{value:"Module"})),ie=A({prefix:"9",name:"base10",alphabet:"0123456789"}),se=Object.freeze(Object.defineProperty({__proto__:null,base10:ie},Symbol.toStringTag,{value:"Module"})),ce=i({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),fe=i({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),le=Object.freeze(Object.defineProperty({__proto__:null,base16:ce,base16upper:fe},Symbol.toStringTag,{value:"Module"})),pe=i({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),de=i({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),be=i({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Ee=i({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),he=i({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Ce=i({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ye=i({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),we=i({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ge=i({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Ae=Object.freeze(Object.defineProperty({__proto__:null,base32:pe,base32hex:he,base32hexpad:ye,base32hexpadupper:we,base32hexupper:Ce,base32pad:be,base32padupper:Ee,base32upper:de,base32z:ge},Symbol.toStringTag,{value:"Module"})),me=A({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Fe=A({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),xe=Object.freeze(Object.defineProperty({__proto__:null,base36:me,base36upper:Fe},Symbol.toStringTag,{value:"Module"})),ve=A({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),_e=A({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Be=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ve,base58flickr:_e},Symbol.toStringTag,{value:"Module"})),Ue=i({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Se=i({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),je=i({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Oe=i({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Te=Object.freeze(Object.defineProperty({__proto__:null,base64:Ue,base64pad:Se,base64url:je,base64urlpad:Oe},Symbol.toStringTag,{value:"Module"})),T=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Pe=T.reduce((e,D,u)=>(e[u]=D,e),[]),ze=T.reduce((e,D,u)=>(e[D.codePointAt(0)]=u,e),[]);function Me(e){return e.reduce((D,u)=>(D+=Pe[u],D),"")}function $e(e){const D=[];for(const u of e){const t=ze[u.codePointAt(0)];if(t===void 0)throw new Error(`Non-base256emoji character: ${u}`);D.push(t)}return new Uint8Array(D)}const ke=x({prefix:"🚀",name:"base256emoji",encode:Me,decode:$e}),Le=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:ke},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const Xe={...te,...ne,...ae,...se,...le,...Ae,...xe,...Be,...Te,...Le};function Ze(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}export{Ge as H,qe as a,Je as b,Ie as c,Ke as d,We as e,Xe as f,Ze as g,Qe as h,$ as n,Re as r,j as t,Ve as u,He as w};
